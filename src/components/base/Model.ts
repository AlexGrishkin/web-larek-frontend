import { IEvents } from '../../types';

// Гарда для проверки на модель
export const isModel = (obj: unknown): obj is Model<any> => {
	return obj instanceof Model;
};

/**
 * abstract class Model<T> говорит о том, что этот класс предназначен для использования только в качестве базового класса, и вы не должны создавать экземпляры этого класса напрямую.
 * То есть при изменение какой либо модели данных происходит уведомления подписчиков что она поменялась
 */
export abstract class Model<T> {
	//Partial<T> означает, что все свойства типа T становятся необязательными.
	// Object.assign(this, data) используется для копирования свойств из объекта data в текущий экземпляр класса. Это способ инициализировать свойства модели при её создании на основе предоставленных данных.
	constructor(data: Partial<T>, protected events: IEvents) {
		Object.assign(this, data);
	}

	// Метод emitChanges используется для оповещения о изменениях в модели, отправляя событие через объект events. В случае наличия payload (дополнительных данных), они также передаются вместе с событием.

	// Класс Model не знает, как реализуется метод emit в объекте events. Он просто определяет интерфейс для работы с событиями через метод emitChanges.
	// Параметр events передается конструктору класса Model и предполагается, что он представляет собой объект, реализующий интерфейс IEvents, который вероятно содержит метод emit для отправки событий.
	//По сути что здесь делается ? Мы знаем что объект events представляет собой пары ключ/значение ['event', 'callback' и др. коллбэки] и когда мы меняем модель данных нам надо знать что все подписчики знали о наличии новых данных и использовали их поэтому применяем к events метод emit который по сути для каждого подписчика вызывает коллбэк с новыми данными модели
	emitChanges(event: string, payload?: object) {
		// Состав данных можно модифицировать
		this.events.emit(event, payload ?? {});
	}

	// далее можно добавить общие методы для моделей
}
